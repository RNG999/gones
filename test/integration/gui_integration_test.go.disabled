// Package integration provides end-to-end GUI integration tests
package integration

import (
	"gones/internal/sdl"
	"testing"
	"time"
)

// TestCompleteGUIIntegration tests the complete GUI integration with emulator components
func TestCompleteGUIIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping GUI integration test in short mode")
	}

	// Create SDL manager
	config := sdl.Config{
		WindowTitle:  "NES Emulator Integration Test",
		WindowWidth:  800,
		WindowHeight: 600,
		TargetFPS:    60,
		AudioConfig:  sdl.DefaultAudioConfig(),
	}

	config.AudioConfig.Callback = func(samples []float32) {
		// Simple silence callback for testing
		for i := range samples {
			samples[i] = 0
		}
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	// Initialize SDL subsystems
	err = manager.Initialize(sdl.SubsystemVideo | sdl.SubsystemAudio | sdl.SubsystemEvents)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping integration test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Create window
	window, err := manager.CreateWindow(config.WindowTitle, config.WindowWidth, config.WindowHeight, uint32(sdl.WindowShown))
	if err != nil {
		t.Fatalf("Failed to create window: %v", err)
	}

	// Create renderer
	renderer, err := manager.CreateRenderer(window, uint32(sdl.RendererAccelerated))
	if err != nil {
		t.Fatalf("Failed to create renderer: %v", err)
	}

	// Create audio device
	_, err = manager.CreateAudioDevice(config.AudioConfig)
	if err != nil {
		t.Fatalf("Failed to create audio device: %v", err)
	}

	// Create input manager
	inputManager, err := manager.CreateInputManager()
	if err != nil {
		t.Fatalf("Failed to create input manager: %v", err)
	}

	// Test basic rendering loop
	testFrameCount := 10
	for frame := 0; frame < testFrameCount; frame++ {
		manager.StartFrame()

		// Clear renderer
		err = renderer.SetDrawColor(sdl.Color{R: 0, G: 0, B: 0, A: 255})
		if err != nil {
			t.Errorf("Failed to set draw color: %v", err)
		}

		err = renderer.Clear()
		if err != nil {
			t.Errorf("Failed to clear renderer: %v", err)
		}

		// Draw test pattern
		for i := 0; i < 100; i++ {
			err = renderer.DrawPoint(int32(i*2), int32(frame*10+i))
			if err != nil {
				t.Errorf("Failed to draw point: %v", err)
			}
		}

		// Present frame
		renderer.Present()

		// Process input events
		events, shouldQuit := inputManager.PollEvents()
		for _, event := range events {
			t.Logf("Input event: %+v", event)
		}

		if shouldQuit {
			t.Log("Quit event received")
			break
		}

		manager.EndFrame()
	}

	t.Logf("Successfully completed %d frame integration test", testFrameCount)
}

// TestGUIWithPPUIntegration tests GUI integration with PPU frame buffer
func TestGUIWithPPUIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping PPU-GUI integration test in short mode")
	}

	// Create mock PPU for testing
	mockPPU := NewMockPPU()

	// Create SDL manager
	config := sdl.Config{
		WindowTitle:  "PPU Integration Test",
		WindowWidth:  800,
		WindowHeight: 600,
		TargetFPS:    60,
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemVideo | sdl.SubsystemEvents)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping integration test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Create window and renderer
	window, err := manager.CreateWindow(config.WindowTitle, config.WindowWidth, config.WindowHeight, uint32(sdl.WindowShown))
	if err != nil {
		t.Fatalf("Failed to create window: %v", err)
	}

	renderer, err := manager.CreateRenderer(window, uint32(sdl.RendererAccelerated))
	if err != nil {
		t.Fatalf("Failed to create renderer: %v", err)
	}

	// Create input manager
	inputManager, err := manager.CreateInputManager()
	if err != nil {
		t.Fatalf("Failed to create input manager: %v", err)
	}

	// Test PPU frame rendering
	testFrames := 5
	for frame := 0; frame < testFrames; frame++ {
		manager.StartFrame()

		// Generate test frame in PPU
		mockPPU.GenerateTestFrame(frame)
		frameBuffer := mockPPU.GetFrameBuffer()

		// Render PPU frame to screen
		err = renderer.RenderNESFrame(frameBuffer[:], 256, 240)
		if err != nil {
			t.Errorf("Failed to render NES frame %d: %v", frame, err)
		}

		renderer.Present()

		// Process input
		events, shouldQuit := inputManager.PollEvents()
		if shouldQuit {
			break
		}

		// Log input events
		for _, event := range events {
			t.Logf("Frame %d input: %+v", frame, event)
		}

		manager.EndFrame()
	}

	t.Logf("Successfully rendered %d PPU frames", testFrames)
}

// TestGUIWithAPUIntegration tests GUI integration with APU audio output
func TestGUIWithAPUIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping APU-GUI integration test in short mode")
	}

	// Create mock APU for testing
	mockAPU := NewMockAPU(44100)

	// Create audio mixer
	mixer := sdl.NewNESAudioMixer(44100, 2, 1024)

	// Create SDL manager with audio
	config := sdl.Config{
		WindowTitle:  "APU Integration Test",
		WindowWidth:  800,
		WindowHeight: 600,
		TargetFPS:    60,
		AudioConfig:  sdl.DefaultAudioConfig(),
	}

	// Set up audio callback to use mixer
	config.AudioConfig.Callback = func(samples []float32) {
		mixer.GetMixedSamples(samples)
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemVideo | sdl.SubsystemAudio | sdl.SubsystemEvents)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping integration test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Create window and renderer
	window, err := manager.CreateWindow(config.WindowTitle, config.WindowWidth, config.WindowHeight, uint32(sdl.WindowShown))
	if err != nil {
		t.Fatalf("Failed to create window: %v", err)
	}

	renderer, err := manager.CreateRenderer(window, uint32(sdl.RendererAccelerated))
	if err != nil {
		t.Fatalf("Failed to create renderer: %v", err)
	}

	// Create audio device
	_, err = manager.CreateAudioDevice(config.AudioConfig)
	if err != nil {
		t.Fatalf("Failed to create audio device: %v", err)
	}

	// Create input manager
	inputManager, err := manager.CreateInputManager()
	if err != nil {
		t.Fatalf("Failed to create input manager: %v", err)
	}

	// Audio device would be started here if we had reference to it

	// Test audio-visual integration
	testDuration := 200 * time.Millisecond
	startTime := time.Now()

	for time.Since(startTime) < testDuration {
		manager.StartFrame()

		// Generate APU samples
		mockAPU.GenerateTestSamples()
		apuSamples := mockAPU.GetSamples()

		// Add samples to mixer
		if len(apuSamples) > 0 {
			mixer.AddNESSamples(apuSamples[:min(len(apuSamples), 100)])
		}

		// Simple visual feedback for audio
		err = renderer.SetDrawColor(sdl.Color{R: 128, G: 128, B: 128, A: 255})
		if err != nil {
			t.Errorf("Failed to set draw color: %v", err)
		}

		err = renderer.Clear()
		if err != nil {
			t.Errorf("Failed to clear renderer: %v", err)
		}

		// Draw audio visualization
		if len(apuSamples) > 0 {
			for i := 0; i < min(len(apuSamples), 800); i++ {
				sample := apuSamples[i]
				y := int32(300 + sample*100) // Center at 300, scale by 100
				err = renderer.DrawPoint(int32(i), y)
				if err != nil {
					t.Errorf("Failed to draw audio point: %v", err)
				}
			}
		}

		renderer.Present()

		// Process input
		events, shouldQuit := inputManager.PollEvents()
		if shouldQuit {
			break
		}

		for _, event := range events {
			t.Logf("Audio test input: %+v", event)
		}

		manager.EndFrame()
	}

	// Audio device would be stopped here if we had reference to it

	t.Log("Successfully completed audio-visual integration test")
}

// TestGUIErrorRecovery tests GUI error recovery scenarios
func TestGUIErrorRecovery(t *testing.T) {
	// Test recovery from various error conditions
	tests := []struct {
		name     string
		testFunc func(*testing.T)
	}{
		{
			name:     "window_creation_failure_recovery",
			testFunc: testWindowCreationFailureRecovery,
		},
		{
			name:     "renderer_creation_failure_recovery",
			testFunc: testRendererCreationFailureRecovery,
		},
		{
			name:     "audio_device_failure_recovery",
			testFunc: testAudioDeviceFailureRecovery,
		},
		{
			name:     "input_system_failure_recovery",
			testFunc: testInputSystemFailureRecovery,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, tt.testFunc)
	}
}

func testWindowCreationFailureRecovery(t *testing.T) {
	config := sdl.Config{
		WindowTitle:  "Recovery Test",
		WindowWidth:  -1, // Invalid width to trigger error
		WindowHeight: 600,
		TargetFPS:    60,
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemVideo)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping recovery test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Attempt to create window with invalid parameters
	_, err = manager.CreateWindow(config.WindowTitle, config.WindowWidth, config.WindowHeight, uint32(sdl.WindowShown))
	if err == nil {
		t.Error("Expected error for invalid window parameters")
	}

	// Recovery: create window with valid parameters
	window, err := manager.CreateWindow("Recovery Window", 800, 600, uint32(sdl.WindowShown))
	if err != nil {
		t.Errorf("Failed to recover and create valid window: %v", err)
	}

	if window != nil {
		defer window.Cleanup()
		t.Log("Successfully recovered from window creation failure")
	}
}

func testRendererCreationFailureRecovery(t *testing.T) {
	config := sdl.Config{
		WindowTitle:  "Renderer Recovery Test",
		WindowWidth:  800,
		WindowHeight: 600,
		TargetFPS:    60,
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemVideo)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping recovery test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Create window
	window, err := manager.CreateWindow(config.WindowTitle, config.WindowWidth, config.WindowHeight, uint32(sdl.WindowShown))
	if err != nil {
		t.Fatalf("Failed to create window: %v", err)
	}

	// Attempt to create renderer with potentially problematic flags
	_, err = manager.CreateRenderer(window, 0xFFFFFFFF) // Invalid flags
	// Note: This might not always fail depending on SDL implementation

	// Recovery: create renderer with standard flags
	renderer, err := manager.CreateRenderer(window, uint32(sdl.RendererAccelerated))
	if err != nil {
		// Try software renderer as fallback
		renderer, err = manager.CreateRenderer(window, uint32(sdl.RendererSoftware))
		if err != nil {
			t.Errorf("Failed to create fallback software renderer: %v", err)
		}
	}

	if renderer != nil {
		defer renderer.Cleanup()
		t.Log("Successfully created renderer (with possible fallback)")
	}
}

func testAudioDeviceFailureRecovery(t *testing.T) {
	config := sdl.Config{
		AudioConfig: sdl.AudioConfig{
			Frequency: -1, // Invalid frequency
			Format:    sdl.AudioFormatF32,
			Channels:  2,
			Samples:   1024,
			Callback: func(samples []float32) {
				for i := range samples {
					samples[i] = 0
				}
			},
		},
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemAudio)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping recovery test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Attempt to create audio device with invalid config
	_, err = manager.CreateAudioDevice(config.AudioConfig)
	if err == nil {
		t.Log("Audio device creation with invalid config succeeded (implementation dependent)")
	}

	// Recovery: create audio device with valid config
	validConfig := sdl.DefaultAudioConfig()
	validConfig.Callback = func(samples []float32) {
		for i := range samples {
			samples[i] = 0
		}
	}

	audioDevice, err := manager.CreateAudioDevice(validConfig)
	if err != nil {
		t.Errorf("Failed to create valid audio device: %v", err)
	}

	if audioDevice != nil {
		defer audioDevice.Cleanup()
		t.Log("Successfully recovered audio device creation")
	}
}

func testInputSystemFailureRecovery(t *testing.T) {
	config := sdl.Config{}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemEvents)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping recovery test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	// Create input manager
	inputManager, err := manager.CreateInputManager()
	if err != nil {
		t.Fatalf("Failed to create input manager: %v", err)
	}

	// Test input manager resilience
	events, quit := inputManager.PollEvents()
	if quit {
		t.Log("Quit event detected during input recovery test")
	}

	if events == nil {
		t.Log("No events returned (expected for test environment)")
	}

	t.Log("Input system recovery test completed")
}

// TestGUIPerformanceUnderLoad tests GUI performance under various load conditions
func TestGUIPerformanceUnderLoad(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping performance test in short mode")
	}

	config := sdl.Config{
		WindowTitle:  "Performance Test",
		WindowWidth:  800,
		WindowHeight: 600,
		TargetFPS:    60,
	}

	manager, err := sdl.NewManager(config)
	if err != nil {
		t.Fatalf("Failed to create SDL manager: %v", err)
	}

	err = manager.Initialize(sdl.SubsystemVideo | sdl.SubsystemEvents)
	if err != nil {
		if isSDLNotAvailable(err) {
			t.Skip("SDL2 not available, skipping performance test")
		}
		t.Fatalf("Failed to initialize SDL: %v", err)
	}
	defer manager.Cleanup()

	window, err := manager.CreateWindow(config.WindowTitle, config.WindowWidth, config.WindowHeight, uint32(sdl.WindowShown))
	if err != nil {
		t.Fatalf("Failed to create window: %v", err)
	}

	renderer, err := manager.CreateRenderer(window, uint32(sdl.RendererAccelerated))
	if err != nil {
		t.Fatalf("Failed to create renderer: %v", err)
	}

	inputManager, err := manager.CreateInputManager()
	if err != nil {
		t.Fatalf("Failed to create input manager: %v", err)
	}

	// Performance test: high draw call count
	testFrames := 30
	drawCallsPerFrame := 1000

	start := time.Now()
	for frame := 0; frame < testFrames; frame++ {
		manager.StartFrame()

		err = renderer.SetDrawColor(sdl.Color{R: 255, G: 255, B: 255, A: 255})
		if err != nil {
			t.Errorf("Failed to set draw color: %v", err)
		}

		err = renderer.Clear()
		if err != nil {
			t.Errorf("Failed to clear renderer: %v", err)
		}

		// High number of draw calls
		for i := 0; i < drawCallsPerFrame; i++ {
			x := int32(i % 800)
			y := int32((i / 800) % 600)
			err = renderer.DrawPoint(x, y)
			if err != nil {
				t.Errorf("Failed to draw point %d: %v", i, err)
			}
		}

		renderer.Present()

		// Process input
		inputManager.PollEvents()

		manager.EndFrame()
	}
	elapsed := time.Since(start)

	totalDrawCalls := testFrames * drawCallsPerFrame
	avgFrameTime := elapsed / time.Duration(testFrames)
	fps := float64(testFrames) / elapsed.Seconds()

	t.Logf("Performance test results:")
	t.Logf("  Total frames: %d", testFrames)
	t.Logf("  Total draw calls: %d", totalDrawCalls)
	t.Logf("  Total time: %v", elapsed)
	t.Logf("  Average frame time: %v", avgFrameTime)
	t.Logf("  Average FPS: %.2f", fps)

	// Performance expectations (reasonable for a test environment)
	if avgFrameTime > 100*time.Millisecond {
		t.Logf("Warning: Average frame time %v is high", avgFrameTime)
	}

	if fps < 10 {
		t.Logf("Warning: Average FPS %.2f is low", fps)
	}
}

// Helper functions for testing

// MockPPU provides a mock PPU for testing
type MockPPU struct {
	frameBuffer [256 * 240]uint32
	frameCount  int
}

// NewMockPPU creates a new mock PPU
func NewMockPPU() *MockPPU {
	return &MockPPU{}
}

// GenerateTestFrame generates a test frame pattern
func (p *MockPPU) GenerateTestFrame(frameNumber int) {
	for y := 0; y < 240; y++ {
		for x := 0; x < 256; x++ {
			i := y*256 + x

			// Create a moving pattern
			r := uint32((x + frameNumber*2) % 256)
			g := uint32((y + frameNumber) % 256)
			b := uint32((x + y + frameNumber) % 256)
			a := uint32(255)

			p.frameBuffer[i] = (r << 24) | (g << 16) | (b << 8) | a
		}
	}
	p.frameCount++
}

// GetFrameBuffer returns the frame buffer
func (p *MockPPU) GetFrameBuffer() [256 * 240]uint32 {
	return p.frameBuffer
}

// MockAPU provides a mock APU for testing
type MockAPU struct {
	sampleRate  int
	samples     []float32
	sampleCount int
	frequency   float64
}

// NewMockAPU creates a new mock APU
func NewMockAPU(sampleRate int) *MockAPU {
	return &MockAPU{
		sampleRate: sampleRate,
		samples:    make([]float32, 1024),
		frequency:  440.0, // A4 note
	}
}

// GenerateTestSamples generates test audio samples
func (a *MockAPU) GenerateTestSamples() {
	samplesPerCycle := float64(a.sampleRate) / a.frequency

	for i := range a.samples {
		// Generate a simple sine wave
		phase := float64(a.sampleCount+i) / samplesPerCycle * 2.0 * 3.14159
		a.samples[i] = float32(0.1 * sine(phase)) // Low volume
	}

	a.sampleCount += len(a.samples)
}

// GetSamples returns the current samples
func (a *MockAPU) GetSamples() []float32 {
	return a.samples
}

// sine approximates the sine function
func sine(x float64) float64 {
	// Simple sine approximation for testing
	for x > 6.28318 {
		x -= 6.28318
	}
	for x < 0 {
		x += 6.28318
	}

	// Taylor series approximation
	return x - (x*x*x)/6 + (x*x*x*x*x)/120
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// isSDLNotAvailable checks if SDL is not available
func isSDLNotAvailable(err error) bool {
	if err == nil {
		return false
	}

	errorStr := err.Error()
	return containsAny(errorStr, []string{
		"No available video device",
		"Could not initialize SDL",
		"SDL not available",
		"no display",
		"DISPLAY not set",
		"audio device",
	})
}

// containsAny checks if a string contains any of the given substrings
func containsAny(str string, substrings []string) bool {
	for _, substr := range substrings {
		if len(str) >= len(substr) {
			for i := 0; i <= len(str)-len(substr); i++ {
				if str[i:i+len(substr)] == substr {
					return true
				}
			}
		}
	}
	return false
}
