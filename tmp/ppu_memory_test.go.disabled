package memory

import (
	"testing"
)

// PPUMemory represents the PPU's memory space for testing
type PPUMemory struct {
	vram       [0x1000]uint8 // 4KB VRAM (nametables)
	paletteRAM [32]uint8     // 32 bytes palette RAM
	cartridge  CartridgeInterface
	mirroring  MirrorMode
}

// MirrorMode represents nametable mirroring mode
type MirrorMode uint8

const (
	MirrorHorizontal MirrorMode = iota
	MirrorVertical
	MirrorSingleScreen0
	MirrorSingleScreen1
	MirrorFourScreen
)

// NewPPUMemory creates a new PPU memory instance
func NewPPUMemory(cart CartridgeInterface, mirroring MirrorMode) *PPUMemory {
	return &PPUMemory{
		cartridge: cart,
		mirroring: mirroring,
	}
}

// Read reads from PPU memory space ($0000-$3FFF)
func (pm *PPUMemory) Read(address uint16) uint8 {
	address &= 0x3FFF // Mask to 14-bit address space
	
	switch {
	case address < 0x2000:
		// Pattern Tables ($0000-$1FFF) - CHR ROM/RAM
		return pm.cartridge.ReadCHR(address)
	
	case address < 0x3000:
		// Nametables ($2000-$2FFF)
		return pm.readNametable(address)
	
	case address < 0x3F00:
		// Nametable mirrors ($3000-$3EFF)
		return pm.readNametable(address - 0x1000)
	
	case address < 0x3F20:
		// Palette RAM ($3F00-$3F1F)
		return pm.readPalette(address)
	
	default:
		// Palette RAM mirrors ($3F20-$3FFF)
		return pm.readPalette(address)
	}
}

// Write writes to PPU memory space ($0000-$3FFF)
func (pm *PPUMemory) Write(address uint16, value uint8) {
	address &= 0x3FFF // Mask to 14-bit address space
	
	switch {
	case address < 0x2000:
		// Pattern Tables ($0000-$1FFF) - CHR ROM/RAM
		pm.cartridge.WriteCHR(address, value)
	
	case address < 0x3000:
		// Nametables ($2000-$2FFF)
		pm.writeNametable(address, value)
	
	case address < 0x3F00:
		// Nametable mirrors ($3000-$3EFF)
		pm.writeNametable(address - 0x1000, value)
	
	case address < 0x3F20:
		// Palette RAM ($3F00-$3F1F)
		pm.writePalette(address, value)
	
	default:
		// Palette RAM mirrors ($3F20-$3FFF)
		pm.writePalette(address, value)
	}
}

// readNametable reads from nametable with mirroring
func (pm *PPUMemory) readNametable(address uint16) uint8 {
	index := pm.getNametableIndex(address)
	return pm.vram[index]
}

// writeNametable writes to nametable with mirroring
func (pm *PPUMemory) writeNametable(address uint16, value uint8) {
	index := pm.getNametableIndex(address)
	pm.vram[index] = value
}

// getNametableIndex calculates the actual VRAM index based on mirroring mode
func (pm *PPUMemory) getNametableIndex(address uint16) uint16 {
	address &= 0x0FFF // Keep only nametable bits
	nametable := (address >> 10) & 3 // Which nametable (0-3)
	offset := address & 0x3FF // Offset within nametable
	
	switch pm.mirroring {
	case MirrorHorizontal:
		// $2000-$23FF and $2400-$27FF map to first 1KB
		// $2800-$2BFF and $2C00-$2FFF map to second 1KB
		if nametable >= 2 {
			return 0x400 + offset
		}
		return offset
	
	case MirrorVertical:
		// $2000-$23FF and $2800-$2BFF map to first 1KB
		// $2400-$27FF and $2C00-$2FFF map to second 1KB
		if nametable == 1 || nametable == 3 {
			return 0x400 + offset
		}
		return offset
	
	case MirrorSingleScreen0:
		// All nametables map to first 1KB
		return offset
	
	case MirrorSingleScreen1:
		// All nametables map to second 1KB
		return 0x400 + offset
	
	case MirrorFourScreen:
		// Each nametable has its own 1KB (requires 4KB VRAM)
		return uint16(nametable)*0x400 + offset
	
	default:
		return offset
	}
}

// readPalette reads from palette RAM with mirroring
func (pm *PPUMemory) readPalette(address uint16) uint8 {
	index := (address - 0x3F00) & 0x1F
	
	// Background color mirroring
	if index == 0x10 || index == 0x14 || index == 0x18 || index == 0x1C {
		index &= 0x0F
	}
	
	return pm.paletteRAM[index]
}

// writePalette writes to palette RAM with mirroring
func (pm *PPUMemory) writePalette(address uint16, value uint8) {
	index := (address - 0x3F00) & 0x1F
	
	// Background color mirroring
	if index == 0x10 || index == 0x14 || index == 0x18 || index == 0x1C {
		index &= 0x0F
	}
	
	pm.paletteRAM[index] = value
}

// Test functions

func TestPPUMemory_PatternTables(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Set up test data in CHR ROM
	cart.chrData[0x0000] = 0x11 // Pattern Table 0 start
	cart.chrData[0x0FFF] = 0x22 // Pattern Table 0 end
	cart.chrData[0x1000] = 0x33 // Pattern Table 1 start
	cart.chrData[0x1FFF] = 0x44 // Pattern Table 1 end
	
	testCases := []struct {
		name string
		address uint16
		expectedValue uint8
	}{
		{"Pattern Table 0 start", 0x0000, 0x11},
		{"Pattern Table 0 end", 0x0FFF, 0x22},
		{"Pattern Table 1 start", 0x1000, 0x33},
		{"Pattern Table 1 end", 0x1FFF, 0x44},
		{"Pattern Table 0 middle", 0x0800, 0x00},
		{"Pattern Table 1 middle", 0x1800, 0x00},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name+" Read", func(t *testing.T) {
			result := ppu.Read(tc.address)
			if result != tc.expectedValue {
				t.Errorf("Read(%04X) = %02X, want %02X", tc.address, result, tc.expectedValue)
			}
			
			// Verify cartridge was called
			if len(cart.chrReads) == 0 {
				t.Fatal("Cartridge ReadCHR not called")
			}
			
			lastCall := cart.chrReads[len(cart.chrReads)-1]
			if lastCall != tc.address {
				t.Errorf("Cartridge ReadCHR called with %04X, want %04X", lastCall, tc.address)
			}
		})
		
		t.Run(tc.name+" Write", func(t *testing.T) {
			value := uint8(0x55)
			ppu.Write(tc.address, value)
			
			// Verify cartridge write was called
			if len(cart.chrWrites) == 0 {
				t.Fatal("Cartridge WriteCHR not called")
			}
			
			lastCall := cart.chrWrites[len(cart.chrWrites)-1]
			if lastCall.Address != tc.address {
				t.Errorf("Cartridge WriteCHR called with address %04X, want %04X", 
					lastCall.Address, tc.address)
			}
			if lastCall.Value != value {
				t.Errorf("Cartridge WriteCHR called with value %02X, want %02X", 
					lastCall.Value, value)
			}
		})
	}
}

func TestPPUMemory_NametableHorizontalMirroring(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test horizontal mirroring: $2000 and $2400 map to same location
	// $2800 and $2C00 map to same location
	mirrorTests := []struct {
		name string
		addr1 uint16
		addr2 uint16
	}{
		{"Nametable 0 and 1", 0x2000, 0x2400},
		{"Nametable 2 and 3", 0x2800, 0x2C00},
		{"Mid table 0 and 1", 0x21FF, 0x25FF},
		{"Mid table 2 and 3", 0x29FF, 0x2DFF},
	}
	
	for _, mt := range mirrorTests {
		t.Run(mt.name, func(t *testing.T) {
			value := uint8(0x42)
			
			// Write to first address
			ppu.Write(mt.addr1, value)
			
			// Read from both addresses - should be same
			result1 := ppu.Read(mt.addr1)
			result2 := ppu.Read(mt.addr2)
			
			if result1 != value {
				t.Errorf("Read(%04X) = %02X, want %02X", mt.addr1, result1, value)
			}
			if result2 != value {
				t.Errorf("Read(%04X) = %02X, want %02X (mirrored)", mt.addr2, result2, value)
			}
			
			// Write to second address
			newValue := uint8(0x84)
			ppu.Write(mt.addr2, newValue)
			
			// Both should now return new value
			result1 = ppu.Read(mt.addr1)
			result2 = ppu.Read(mt.addr2)
			
			if result1 != newValue {
				t.Errorf("After mirror write, Read(%04X) = %02X, want %02X", mt.addr1, result1, newValue)
			}
			if result2 != newValue {
				t.Errorf("After mirror write, Read(%04X) = %02X, want %02X", mt.addr2, result2, newValue)
			}
		})
	}
}

func TestPPUMemory_NametableVerticalMirroring(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorVertical)
	
	// Test vertical mirroring: $2000 and $2800 map to same location
	// $2400 and $2C00 map to same location
	mirrorTests := []struct {
		name string
		addr1 uint16
		addr2 uint16
	}{
		{"Nametable 0 and 2", 0x2000, 0x2800},
		{"Nametable 1 and 3", 0x2400, 0x2C00},
		{"Mid table 0 and 2", 0x21FF, 0x29FF},
		{"Mid table 1 and 3", 0x25FF, 0x2DFF},
	}
	
	for _, mt := range mirrorTests {
		t.Run(mt.name, func(t *testing.T) {
			value := uint8(0x73)
			
			// Write to first address
			ppu.Write(mt.addr1, value)
			
			// Read from both addresses - should be same
			result1 := ppu.Read(mt.addr1)
			result2 := ppu.Read(mt.addr2)
			
			if result1 != value {
				t.Errorf("Read(%04X) = %02X, want %02X", mt.addr1, result1, value)
			}
			if result2 != value {
				t.Errorf("Read(%04X) = %02X, want %02X (mirrored)", mt.addr2, result2, value)
			}
		})
	}
}

func TestPPUMemory_NametableSingleScreenMirroring(t *testing.T) {
	mirrorModes := []struct {
		mode MirrorMode
		name string
	}{
		{MirrorSingleScreen0, "Single Screen 0"},
		{MirrorSingleScreen1, "Single Screen 1"},
	}
	
	for _, mm := range mirrorModes {
		t.Run(mm.name, func(t *testing.T) {
			cart := &MockCartridge{}
			ppu := NewPPUMemory(cart, mm.mode)
			
			// All nametable addresses should map to the same location
			addresses := []uint16{0x2000, 0x2400, 0x2800, 0x2C00}
			value := uint8(0x99)
			
			// Write to first address
			ppu.Write(addresses[0], value)
			
			// All addresses should return the same value
			for _, addr := range addresses {
				result := ppu.Read(addr)
				if result != value {
					t.Errorf("Read(%04X) = %02X, want %02X", addr, result, value)
				}
			}
		})
	}
}

func TestPPUMemory_NametableFourScreenMirroring(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorFourScreen)
	
	// Each nametable should be independent
	nametables := []struct {
		addr uint16
		value uint8
	}{
		{0x2000, 0x11}, // Nametable 0
		{0x2400, 0x22}, // Nametable 1
		{0x2800, 0x33}, // Nametable 2
		{0x2C00, 0x44}, // Nametable 3
	}
	
	// Write unique values to each nametable
	for _, nt := range nametables {
		ppu.Write(nt.addr, nt.value)
	}
	
	// Verify each nametable retains its unique value
	for _, nt := range nametables {
		result := ppu.Read(nt.addr)
		if result != nt.value {
			t.Errorf("Read(%04X) = %02X, want %02X", nt.addr, result, nt.value)
		}
	}
}

func TestPPUMemory_NametableMirrors(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test nametable mirrors at $3000-$3EFF
	mirrorTests := []struct {
		name string
		baseAddr uint16
		mirrorAddr uint16
	}{
		{"Nametable 0 mirror", 0x2000, 0x3000},
		{"Nametable 1 mirror", 0x2400, 0x3400},
		{"Nametable 2 mirror", 0x2800, 0x3800},
		{"Nametable 3 mirror", 0x2C00, 0x3C00},
		{"Mid nametable mirror", 0x21FF, 0x31FF},
		{"End nametable mirror", 0x2EFF, 0x3EFF},
	}
	
	for _, mt := range mirrorTests {
		t.Run(mt.name, func(t *testing.T) {
			value := uint8(0x66)
			
			// Write to base address
			ppu.Write(mt.baseAddr, value)
			
			// Read from mirror should return same value
			result := ppu.Read(mt.mirrorAddr)
			if result != value {
				t.Errorf("Mirror read: Read(%04X) = %02X, want %02X", mt.mirrorAddr, result, value)
			}
			
			// Write to mirror
			newValue := uint8(0x77)
			ppu.Write(mt.mirrorAddr, newValue)
			
			// Base address should now return new value
			result = ppu.Read(mt.baseAddr)
			if result != newValue {
				t.Errorf("After mirror write: Read(%04X) = %02X, want %02X", mt.baseAddr, result, newValue)
			}
		})
	}
}

func TestPPUMemory_PaletteRAM(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test basic palette access
	paletteTests := []struct {
		name string
		address uint16
		value uint8
	}{
		{"Background palette 0 color 0", 0x3F00, 0x0F},
		{"Background palette 0 color 1", 0x3F01, 0x30},
		{"Background palette 1 color 0", 0x3F04, 0x00},
		{"Sprite palette 0 color 0", 0x3F10, 0x0F},
		{"Sprite palette 0 color 1", 0x3F11, 0x16},
		{"Sprite palette 3 color 3", 0x3F1F, 0x27},
	}
	
	for _, pt := range paletteTests {
		t.Run(pt.name, func(t *testing.T) {
			ppu.Write(pt.address, pt.value)
			result := ppu.Read(pt.address)
			
			if result != pt.value {
				t.Errorf("Read(%04X) = %02X, want %02X", pt.address, result, pt.value)
			}
		})
	}
}

func TestPPUMemory_PaletteBackgroundMirroring(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test background color mirroring
	// $3F10, $3F14, $3F18, $3F1C mirror $3F00, $3F04, $3F08, $3F0C
	mirrorTests := []struct {
		name string
		bgAddr uint16
		spriteAddr uint16
	}{
		{"Palette 0 background", 0x3F00, 0x3F10},
		{"Palette 1 background", 0x3F04, 0x3F14},
		{"Palette 2 background", 0x3F08, 0x3F18},
		{"Palette 3 background", 0x3F0C, 0x3F1C},
	}
	
	for _, mt := range mirrorTests {
		t.Run(mt.name, func(t *testing.T) {
			value := uint8(0x22)
			
			// Write to background palette
			ppu.Write(mt.bgAddr, value)
			
			// Sprite palette background should return same value
			result := ppu.Read(mt.spriteAddr)
			if result != value {
				t.Errorf("Sprite palette read: Read(%04X) = %02X, want %02X", mt.spriteAddr, result, value)
			}
			
			// Write to sprite palette background
			newValue := uint8(0x33)
			ppu.Write(mt.spriteAddr, newValue)
			
			// Background palette should return new value
			result = ppu.Read(mt.bgAddr)
			if result != newValue {
				t.Errorf("Background palette read: Read(%04X) = %02X, want %02X", mt.bgAddr, result, newValue)
			}
		})
	}
}

func TestPPUMemory_PaletteMirrors(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test palette mirrors every 32 bytes
	baseAddresses := []uint16{0x3F00, 0x3F01, 0x3F10, 0x3F1F}
	
	for _, baseAddr := range baseAddresses {
		t.Run("Palette mirror", func(t *testing.T) {
			value := uint8(baseAddr & 0xFF)
			
			// Write to base address
			ppu.Write(baseAddr, value)
			
			// Test mirrors up to end of address space
			for mirrorAddr := baseAddr + 32; mirrorAddr <= 0x3FFF; mirrorAddr += 32 {
				result := ppu.Read(mirrorAddr)
				if result != value {
					t.Errorf("Mirror read: Read(%04X) = %02X, want %02X", mirrorAddr, result, value)
				}
			}
		})
	}
}

func TestPPUMemory_AddressWrapping(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test that addresses wrap within 14-bit space
	wrapTests := []struct {
		name string
		address uint16
		expectedMasked uint16
	}{
		{"14-bit boundary", 0x4000, 0x0000},
		{"15-bit boundary", 0x8000, 0x0000},
		{"16-bit boundary", 0x0000, 0x0000}, // Already within range
		{"High address", 0xFFFF, 0x3FFF},
		{"Mid-high address", 0x7234, 0x3234},
	}
	
	for _, wt := range wrapTests {
		t.Run(wt.name, func(t *testing.T) {
			// This tests internal address masking
			// We can't directly observe the masking, but we can test behavior
			
			// Should not panic
			result := ppu.Read(wt.address)
			_ = result
			
			ppu.Write(wt.address, 0x42)
		})
	}
}

func TestPPUMemory_ComprehensiveAccess(t *testing.T) {
	cart := &MockCartridge{}
	ppu := NewPPUMemory(cart, MirrorHorizontal)
	
	// Test access to all major regions
	regions := []struct {
		name string
		startAddr uint16
		endAddr uint16
		testAddr uint16
	}{
		{"Pattern Table 0", 0x0000, 0x0FFF, 0x0500},
		{"Pattern Table 1", 0x1000, 0x1FFF, 0x1500},
		{"Nametable 0", 0x2000, 0x23FF, 0x2100},
		{"Nametable 1", 0x2400, 0x27FF, 0x2500},
		{"Nametable 2", 0x2800, 0x2BFF, 0x2900},
		{"Nametable 3", 0x2C00, 0x2FFF, 0x2D00},
		{"Nametable mirrors", 0x3000, 0x3EFF, 0x3100},
		{"Palette RAM", 0x3F00, 0x3F1F, 0x3F10},
		{"Palette mirrors", 0x3F20, 0x3FFF, 0x3F80},
	}
	
	for _, region := range regions {
		t.Run(region.name, func(t *testing.T) {
			// Test read and write access
			value := uint8(region.testAddr & 0xFF)
			
			ppu.Write(region.testAddr, value)
			result := ppu.Read(region.testAddr)
			
			// For pattern tables, verify cartridge access
			if region.testAddr < 0x2000 {
				if len(cart.chrWrites) == 0 {
					t.Error("Pattern table write did not access cartridge")
				}
				if len(cart.chrReads) == 0 {
					t.Error("Pattern table read did not access cartridge")
				}
			} else {
				// For VRAM/palette, value should match
				// (Note: actual value may differ due to mirroring)
				_ = result // Don't check exact value due to mirroring complexity
			}
		})
	}
}